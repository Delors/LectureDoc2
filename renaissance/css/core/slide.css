/*  CSS LAYER: behavior */

/*  Core styling of slides. */
ld-slide {
    --ld-rendering-mode: slide;

    contain: layout paint size;
    contain-intrinsic-size: var(--ld-slide-width) var(--ld-slide-height);

    /*  We need a fixed size for slides to make the content as a whole
        scalable using the scale property. The scale property is set/updated
        using Javascript.

        Conceptually, - for the slides/light-table view - we would like to have
        some CSS like:

            scale: min(calc(100vh/1080px),calc(100vw/1920px));

        But such CSS computations are not yet supported - at least as of 2024.

        The actual (fixed) size, however, doesn't really matter from
        LectureDoc's point-of-view, because the content is scaled anyway.
        Nevertheless, when external content is embedded (in
        particular images) it makes sense to have a size that resembles a
        "natural" screen resolution to make it meaningful to embed images.
    */
    width: var(--ld-slide-width);
    height: var(--ld-slide-height);

    overflow: hidden;

    /*
    object[role="img"][type="image/svg+xml"],
    img {
        Done by JavaScript, to get the correct box dimensions!
        scale: ~3;
    }
    */

    /* We simulate a deck by creating a CSS Grid with a single cell and 
    assigning all cards the same cell. To ensure that the cards are shown in 
    the correct order, we also associate each card with its corresponding z-index.
    */
    ld-deck {
        /*  Every deck creates a unique stacking context. This enables us 
            to put the "cards" of a deck on top of each other. To enable a
            perfect overlay, all "cards" are given the same size as the deck. 
            
            Because every direct child element is treated as a card and
            will get the size of the deck, elements which need an explicit size 
            of their own (e.g., images) need to be put into a generic container.
            */
        position: relative;
        z-index: 0;

        display: grid;
        grid-template-columns: 1fr;
        grid-template-rows: auto;
        grid-template-areas: "stack";

        width: 100%;

        /*  Let's count the number of child elements.

            The idea is based on the following discussion:
            https://stackoverflow.com/questions/8720931/can-css-detect-the-number-of-children-an-element-has */
        &:has(> :last-child:nth-child(1)) {
            --ld-deck-child-count: 1;
        }
        &:has(> :last-child:nth-child(2)) {
            --ld-deck-child-count: 2;
        }
        &:has(> :last-child:nth-child(3)) {
            --ld-deck-child-count: 3;
        }
        &:has(> :last-child:nth-child(4)) {
            --ld-deck-child-count: 4;
        }
        &:has(> :last-child:nth-child(5)) {
            --ld-deck-child-count: 5;
        }
        &:has(> :last-child:nth-child(6)) {
            --ld-deck-child-count: 6;
        }
        &:has(> :last-child:nth-child(7)) {
            --ld-deck-child-count: 7;
        }
        &:has(> :last-child:nth-child(8)) {
            --ld-deck-child-count: 8;
        }
        &:has(> :last-child:nth-child(9)) {
            --ld-deck-child-count: 9;
        }
        &:has(> :last-child:nth-child(10)) {
            --ld-deck-child-count: 10;
        }
        &:has(> :last-child:nth-child(11)) {
            --ld-deck-child-count: 11;
        }
        &:has(> :last-child:nth-child(12)) {
            --ld-deck-child-count: 12;
        }
        &:has(> :last-child:nth-child(13)) {
            --ld-deck-child-count: 13;
        }
        &:has(> :last-child:nth-child(14)) {
            --ld-deck-child-count: 14;
        }
        &:has(> :last-child:nth-child(15)) {
            --ld-deck-child-count: 15;
        }

        /*
        First, we associate the nth-child layer with a custom data attribute 
        index that we then use in the css calculations!

        See https://crinkles.dev/writing/a-nth-child-css-trick/
        See https://crinkles.dev/writing/use-the-child-element-count-in-css/ 
        */
        /* Initialize counter for deck children */
        counter-reset: deck-child-index;
        
        > * {
            /* Use CSS counter to get the actual index */
            counter-increment: deck-child-index;
            --ld-deck-child-index: counter(deck-child-index);
            
            /* The card's index is now set using CSS counter and determines the z-index */
            grid-area: stack;
            width: 100%;
            height: 100%;
            z-index: var(--ld-deck-child-index);

            clear: both;
            overflow: hidden;

            &:not(.overlay, .s-overlay) {
                background-color: var(--current-background-color);
            }
        }
    }

    ld-scrollable {
        display: block;
        overflow: auto;
    }

    ld-story {
        display: block;
        width: 100%;
        height: 100%; /* will be set to the remaining height by JavaScript */
        overflow: hidden;
    }

    object[role="img"][type="image/svg+xml"] {
        pointer-events: none;
    }
}
